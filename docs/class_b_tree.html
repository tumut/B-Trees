<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>BTrees: BTree&lt; TKey, M &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BTrees
   </div>
   <div id="projectbrief">B-Tree implementation in C++ to index documents based on numerical id&#39;s and title strings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_b_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BTree&lt; TKey, M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe de árvore B.  
 <a href="class_b_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_b_tree_8hpp_source.html">BTree.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for BTree&lt; TKey, M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_b_tree__coll__graph.png" border="0" usemap="#_b_tree_3_01_t_key_00_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_b_tree_3_01_t_key_00_01_m_01_4_coll__map" id="_b_tree_3_01_t_key_00_01_m_01_4_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nó da árvore B.  <a href="struct_b_tree_1_1_b_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dados do cabeçalho do arquivo.  <a href="struct_b_tree_1_1_file_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registro auxiliar com o resultado de um overflow de inserção.  <a href="struct_b_tree_1_1_overflow_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estrutura usada pela árvore para guardar métricas de sua execução.  <a href="struct_b_tree_1_1_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace2795117ce7ba73e15b52c72b3a10b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#ace2795117ce7ba73e15b52c72b3a10b3">BTree</a> ()</td></tr>
<tr class="memdesc:ace2795117ce7ba73e15b52c72b3a10b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construtor padrão.  <a href="#ace2795117ce7ba73e15b52c72b3a10b3">More...</a><br /></td></tr>
<tr class="separator:ace2795117ce7ba73e15b52c72b3a10b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb2c2201c1c7b3ebf0719c21c3fc866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#afbb2c2201c1c7b3ebf0719c21c3fc866">~BTree</a> ()</td></tr>
<tr class="memdesc:afbb2c2201c1c7b3ebf0719c21c3fc866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destrutor padrão.  <a href="#afbb2c2201c1c7b3ebf0719c21c3fc866">More...</a><br /></td></tr>
<tr class="separator:afbb2c2201c1c7b3ebf0719c21c3fc866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e5c6367eed5e552b4fdfe51aad61b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#aab8e5c6367eed5e552b4fdfe51aad61b">create</a> (const char *filepath)</td></tr>
<tr class="memdesc:aab8e5c6367eed5e552b4fdfe51aad61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Método de inicialização da árvore, para escrita.  <a href="#aab8e5c6367eed5e552b4fdfe51aad61b">More...</a><br /></td></tr>
<tr class="separator:aab8e5c6367eed5e552b4fdfe51aad61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f314aa35d198aa82d96d030b2ba4404"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a3f314aa35d198aa82d96d030b2ba4404">load</a> (const char *filepath)</td></tr>
<tr class="memdesc:a3f314aa35d198aa82d96d030b2ba4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Método de inicialização da árvore, para leitura.  <a href="#a3f314aa35d198aa82d96d030b2ba4404">More...</a><br /></td></tr>
<tr class="separator:a3f314aa35d198aa82d96d030b2ba4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcaee02bde80ebe5e1634be84357900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a2dcaee02bde80ebe5e1634be84357900">insert</a> (const TKey &amp;key)</td></tr>
<tr class="memdesc:a2dcaee02bde80ebe5e1634be84357900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insere um dado dentro da árvore.  <a href="#a2dcaee02bde80ebe5e1634be84357900">More...</a><br /></td></tr>
<tr class="separator:a2dcaee02bde80ebe5e1634be84357900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39de078a8dfb556c4f665c5791ba6ac"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; TKey &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#ac39de078a8dfb556c4f665c5791ba6ac">seek</a> (const TKey &amp;key)</td></tr>
<tr class="memdesc:ac39de078a8dfb556c4f665c5791ba6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca um dado que seja equivalente ao dado fornecido.  <a href="#ac39de078a8dfb556c4f665c5791ba6ac">More...</a><br /></td></tr>
<tr class="separator:ac39de078a8dfb556c4f665c5791ba6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b36fa86b3b3e9b4566ba3b622e107e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a7b36fa86b3b3e9b4566ba3b622e107e3">getStatistics</a> (bool includeFileBlockCount=false) const </td></tr>
<tr class="memdesc:a7b36fa86b3b3e9b4566ba3b622e107e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna as estatísticas da árvore até então.  <a href="#a7b36fa86b3b3e9b4566ba3b622e107e3">More...</a><br /></td></tr>
<tr class="separator:a7b36fa86b3b3e9b4566ba3b622e107e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e20ba0b14f93b20302fcb5bd4932dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#aa8e20ba0b14f93b20302fcb5bd4932dd">resetStatistics</a> ()</td></tr>
<tr class="memdesc:aa8e20ba0b14f93b20302fcb5bd4932dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atribui valor 0 a todos os campos das estatísticas atuais.  <a href="#aa8e20ba0b14f93b20302fcb5bd4932dd">More...</a><br /></td></tr>
<tr class="separator:aa8e20ba0b14f93b20302fcb5bd4932dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5c0ac3e9ade90c7a830406ecb26f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a4d5c0ac3e9ade90c7a830406ecb26f45">finishInsertions</a> ()</td></tr>
<tr class="memdesc:a4d5c0ac3e9ade90c7a830406ecb26f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atualiza o cabeçalho com o total de blocos no arquivo.  <a href="#a4d5c0ac3e9ade90c7a830406ecb26f45">More...</a><br /></td></tr>
<tr class="separator:a4d5c0ac3e9ade90c7a830406ecb26f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa4744d293938bd1368e2f1221e85cf03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#aa4744d293938bd1368e2f1221e85cf03">readFromDisk</a> (long offset)</td></tr>
<tr class="memdesc:aa4744d293938bd1368e2f1221e85cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna um bloco com o nó lido no offset fornecido.  <a href="#aa4744d293938bd1368e2f1221e85cf03">More...</a><br /></td></tr>
<tr class="separator:aa4744d293938bd1368e2f1221e85cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70baf9a02151ed8a897eee0b2d9ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a9d70baf9a02151ed8a897eee0b2d9ed5">writeToDisk</a> (<a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a9d70baf9a02151ed8a897eee0b2d9ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atualiza em disco o nó fornecido.  <a href="#a9d70baf9a02151ed8a897eee0b2d9ed5">More...</a><br /></td></tr>
<tr class="separator:a9d70baf9a02151ed8a897eee0b2d9ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a652ee2fe86c5de933590ecc1613c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a96a652ee2fe86c5de933590ecc1613c2">readHeader</a> () const </td></tr>
<tr class="memdesc:a96a652ee2fe86c5de933590ecc1613c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lê em disco o cabeçalho do arquivo da árvore.  <a href="#a96a652ee2fe86c5de933590ecc1613c2">More...</a><br /></td></tr>
<tr class="separator:a96a652ee2fe86c5de933590ecc1613c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c36f654fa44f096324c677a8fd7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a373c36f654fa44f096324c677a8fd7ad">writeHeader</a> (const <a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; &amp;header)</td></tr>
<tr class="memdesc:a373c36f654fa44f096324c677a8fd7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atualiza o cabeçalho do arquivo da arvore.  <a href="#a373c36f654fa44f096324c677a8fd7ad">More...</a><br /></td></tr>
<tr class="separator:a373c36f654fa44f096324c677a8fd7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad724e5c7ea6f668060846cbbe15368"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#afad724e5c7ea6f668060846cbbe15368">insert</a> (<a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;node, TKey key, long rightNodeOffset=-1)</td></tr>
<tr class="memdesc:afad724e5c7ea6f668060846cbbe15368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Método interno de inserção na árvore.  <a href="#afad724e5c7ea6f668060846cbbe15368">More...</a><br /></td></tr>
<tr class="separator:afad724e5c7ea6f668060846cbbe15368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aea30be3db9c762b8d9fe7e44dd4c3c29"><td class="memItemLeft" align="right" valign="top">std::FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#aea30be3db9c762b8d9fe7e44dd4c3c29">m_file</a></td></tr>
<tr class="memdesc:aea30be3db9c762b8d9fe7e44dd4c3c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ponteiro de arquivo para o arquivo em que se encontram os dados da árvore.  <a href="#aea30be3db9c762b8d9fe7e44dd4c3c29">More...</a><br /></td></tr>
<tr class="separator:aea30be3db9c762b8d9fe7e44dd4c3c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1658bf8173fb5c33944615ebaaee69d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a1658bf8173fb5c33944615ebaaee69d0">m_root</a></td></tr>
<tr class="memdesc:a1658bf8173fb5c33944615ebaaee69d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nó raiz da árvore.  <a href="#a1658bf8173fb5c33944615ebaaee69d0">More...</a><br /></td></tr>
<tr class="separator:a1658bf8173fb5c33944615ebaaee69d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5142aee6795ec77ea67c3f7702801890"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a5142aee6795ec77ea67c3f7702801890">m_stats</a></td></tr>
<tr class="memdesc:a5142aee6795ec77ea67c3f7702801890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Onde a <a class="el" href="class_b_tree.html" title="Classe de árvore B. ">BTree</a> guarda suas estatísticas de leitura e escrita de blocos.  <a href="#a5142aee6795ec77ea67c3f7702801890">More...</a><br /></td></tr>
<tr class="separator:a5142aee6795ec77ea67c3f7702801890"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class TKey, std::size_t M&gt;<br />
class BTree&lt; TKey, M &gt;</h3>

<p>Classe de árvore B. </p>
<p>Classe de árvore B multi-uso usada para guardar índices e títulos no trabalho.</p>
<p>O parâmetro de template TKey determina o tipo de dado que será guardado nos nós da árvore. TKey deve ser um tipo POD (Plain Old Data type) para poder ser sequenciado no arquivo quando o nó for escrito.</p>
<p>O parâmetro de template M determina a ordem da árvore. Em condições normais, um nó pode ter no máximo 2M dados e 2M+1 apontadores de nó. Em estado de overflow, ele pode temporariamente ter 2M+1 dados e 2M+2 apontadores de nó.</p>
<p>Antes de usar uma <a class="el" href="class_b_tree.html" title="Classe de árvore B. ">BTree</a> deve sempre se chamar o método load (em caso de apenas leitura) ou create (em caso de escrita de um novo arquivo).</p>
<p>No fim da inserção, o método <a class="el" href="class_b_tree.html#a4d5c0ac3e9ade90c7a830406ecb26f45" title="Atualiza o cabeçalho com o total de blocos no arquivo. ">finishInsertions()</a> deve ser chamado para a quantidade de blocos do arquivo ser atualizada no cabeçalho.</p>
<p>Exemplo de uso: </p><div class="fragment"><div class="line"><a class="code" href="class_b_tree.html">BTree&lt;int, 2&gt;</a> arvore;</div><div class="line">arvore.<a class="code" href="class_b_tree.html#aab8e5c6367eed5e552b4fdfe51aad61b">create</a>(<span class="stringliteral">&quot;nomedoarquivo.bin&quot;</span>);</div><div class="line">arvore.<a class="code" href="class_b_tree.html#a2dcaee02bde80ebe5e1634be84357900">insert</a>(1);</div><div class="line">arvore.<a class="code" href="class_b_tree.html#a4d5c0ac3e9ade90c7a830406ecb26f45">finishInsertions</a>();</div><div class="line"></div><div class="line">arvore.<a class="code" href="class_b_tree.html#a3f314aa35d198aa82d96d030b2ba4404">load</a>(<span class="stringliteral">&quot;nomedoarquivo.bin&quot;</span>);</div><div class="line"><span class="keyword">auto</span> valor = arvore.<a class="code" href="class_b_tree.html#ac39de078a8dfb556c4f665c5791ba6ac">seek</a>(1);</div><div class="line"><span class="keywordflow">if</span> (valor) f(*valor); <span class="comment">// Fazer algo com o valor, se encontrado.</span></div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace2795117ce7ba73e15b52c72b3a10b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::<a class="el" href="class_b_tree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construtor padrão. </p>
<p>Inicializa com valores 0 as estatísticas e nulifica o ponteiro de arquivo da <a class="el" href="class_b_tree.html" title="Classe de árvore B. ">BTree</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="afbb2c2201c1c7b3ebf0719c21c3fc866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::~<a class="el" href="class_b_tree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destrutor padrão. </p>
<p>Fecha o arquivo se ele estiver aberto. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aab8e5c6367eed5e552b4fdfe51aad61b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Método de inicialização da árvore, para escrita. </p>
<p>Deve sempre ser chamado antes de começar a inserção na árvore, mas também permite a leitura.</p>
<p>Se já houver um arquivo em filepath, ele será sobreescrito.</p>
<p>O arquivo novo será criado com um cabeçalho e um nó raiz vazio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Caminho do arquivo onde os dados da árvore serão escritos.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Se foi possível criar o arquivo em filepath.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a4d5c0ac3e9ade90c7a830406ecb26f45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::finishInsertions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atualiza o cabeçalho com o total de blocos no arquivo. </p>
<p>Muito importante de se usar no final da utilização de uma árvore após ela ser inicializada com <a class="el" href="class_b_tree.html#aab8e5c6367eed5e552b4fdfe51aad61b" title="Método de inicialização da árvore, para escrita. ">create()</a>.</p>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a7b36fa86b3b3e9b4566ba3b622e107e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::<a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a> <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::getStatistics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFileBlockCount</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna as estatísticas da árvore até então. </p>
<p>A inclusão da quantidade de blocos no arquivo, nas estatísticas, é opcional pois a árvore vai ter que fazer uma leitura do arquivo para poder obter este dado, o que é uma operação custosa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeFileBlockCount</td><td>Se deve incluir (true) ou não (false) a quantidade de blocos do arquivo nas estatísticas.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Estatísticas.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a2dcaee02bde80ebe5e1634be84357900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insere um dado dentro da árvore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>O dado a ser inserido.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="afad724e5c7ea6f668060846cbbe15368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::<a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKey&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rightNodeOffset</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Método interno de inserção na árvore. </p>
<p>Caso o nó seja uma folha, ele busca o apontador de nó para o nó em que o dado deve ser inserido e tenta novamente de forma recursiva. Caso não seja uma folha, ele faz a inserção normalmente.</p>
<p>Em caso de overflow, a função irá realizar um split no nó fornecido por parâmetro e irá retornar dados para o nó pai lidar com o overflow. Ele irá tentar inserir novamente, dessa vez em si mesmo.</p>
<p>O valor de rightNodeOffset só será diferente de -1 se a função estiver lidando com um overflow previamente encontrado. No caso, node será um nó pai que precisa tentar inserir o dado que restou no último split.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>O nó em que o dado está sendo inserido. </td></tr>
    <tr><td class="paramname">key</td><td>O dado a ser inserido. </td></tr>
    <tr><td class="paramname">rightNodeOffset</td><td>O offset do nó à direita do dado a ser inserido; caso seja -1, ele não existe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dados de overflow caso tenha houvido um, ou nulo.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a3f314aa35d198aa82d96d030b2ba4404"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Método de inicialização da árvore, para leitura. </p>
<p>Deve sempre ser chamado antes de começar a leitura da árvore. Inserções não serão possíveis.</p>
<p>O arquivo deve existir previamente, de preferência criado por outra execução da <a class="el" href="class_b_tree.html" title="Classe de árvore B. ">BTree</a> após uma chamada de <a class="el" href="class_b_tree.html#aab8e5c6367eed5e552b4fdfe51aad61b" title="Método de inicialização da árvore, para escrita. ">create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Caminho pro arquivo onde se encontram os dados da árvore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Se foi possível abrir o arquivo em filepath.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="aa4744d293938bd1368e2f1221e85cf03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::<a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::readFromDisk </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna um bloco com o nó lido no offset fornecido. </p>
<p>O resultado da função é indefinido se for fornecido um offset inválido. Presume-se que apenas offsets válidos, com arquivos válidos, serão fornecidos para esta função.</p>
<p>Esta função incrementa o valor de blocos lidos, nas estatísticas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>O offset do nó no arquivo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Um bloco com o nó no offset.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a96a652ee2fe86c5de933590ecc1613c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::<a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::readHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lê em disco o cabeçalho do arquivo da árvore. </p>
<p>Esta função tem retorno indefinido se chamada enquanto a árvore ainda não estiver sido inicializada e o arquivo não estiver aberto. Presume-se que ela sempre será chamada em condições satisfatórias.</p>
<p>Esta função incrementa a quantidade de blocos lidos nas estatísticas.</p>
<dl class="section return"><dt>Returns</dt><dd>O bloco com o cabeçalho do arquivo.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="aa8e20ba0b14f93b20302fcb5bd4932dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::resetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atribui valor 0 a todos os campos das estatísticas atuais. </p>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="ac39de078a8dfb556c4f665c5791ba6ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; TKey &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::seek </td>
          <td>(</td>
          <td class="paramtype">const TKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busca um dado que seja equivalente ao dado fornecido. </p>
<p>Não há garantias que o dado realmente será buscado. Caso não seja encontrado, a função retorna um ponteiro nulo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>O dado que se está buscando.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro com o dado ou nulo.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a373c36f654fa44f096324c677a8fd7ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::writeHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atualiza o cabeçalho do arquivo da arvore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Bloco com instância de cabeçalho possuindo os novos valores do cabeçalho do arquivo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<a class="anchor" id="a9d70baf9a02151ed8a897eee0b2d9ed5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::writeToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atualiza em disco o nó fornecido. </p>
<p>Caso o nó ainda não tenha sido escrito em disco, ou seja, possua offset inválido (-1), o nó é concatenado ao fim do arquivo e seu offset atualizado com sua nova posição.</p>
<p>Esta função incrementa o valor de blocos criados, nas estatísticas, no caso descrito anteriormente.</p>
<p>Caso o nó já tenha sido escrito, ou seja, possua offset válido, o nó é simplesmente atualizado.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>O nó a ser escrito.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Timóteo Fonseca </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aea30be3db9c762b8d9fe7e44dd4c3c29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::FILE* <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::m_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ponteiro de arquivo para o arquivo em que se encontram os dados da árvore. </p>

</div>
</div>
<a class="anchor" id="a1658bf8173fb5c33944615ebaaee69d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt;<a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a>&gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::m_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nó raiz da árvore. </p>

</div>
</div>
<a class="anchor" id="a5142aee6795ec77ea67c3f7702801890"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TKey, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a> <a class="el" href="class_b_tree.html">BTree</a>&lt; TKey, M &gt;::m_stats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Onde a <a class="el" href="class_b_tree.html" title="Classe de árvore B. ">BTree</a> guarda suas estatísticas de leitura e escrita de blocos. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_b_tree_8hpp_source.html">BTree.hpp</a></li>
<li>include/<a class="el" href="_b_tree_8inl.html">BTree.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
