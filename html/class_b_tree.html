<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>BTrees: BTree&lt; T, M &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BTrees
   </div>
   <div id="projectbrief">B-Tree implementation in C++ to index documents based on numerical id&#39;s and title strings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_b_tree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BTree&lt; T, M &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>B-tree class.  
 <a href="class_b_tree.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_b_tree_8hpp_source.html">BTree.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for BTree&lt; T, M &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_b_tree__coll__graph.png" border="0" usemap="#_b_tree_3_01_t_00_01_m_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_b_tree_3_01_t_00_01_m_01_4_coll__map" id="_b_tree_3_01_t_00_01_m_01_4_coll__map">
<area shape="rect" id="node2" href="union_block.html" title="Block\&lt; BTree::BNode \&gt;" alt="" coords="5,95,168,121"/>
<area shape="rect" id="node3" href="struct_b_tree_1_1_b_node.html" title="B&#45;tree node. " alt="" coords="9,5,165,32"/>
<area shape="rect" id="node4" href="struct_b_tree_1_1_statistics.html" title="Stored analytics of the BTree usage. " alt="" coords="192,95,363,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">B-tree node.  <a href="struct_b_tree_1_1_b_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">File header data.  <a href="struct_b_tree_1_1_file_header.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary struct with results from an insertion overflow.  <a href="struct_b_tree_1_1_overflow_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stored analytics of the <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> usage.  <a href="struct_b_tree_1_1_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04ccfa104341dc5b3d858f6ecfaff1f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a04ccfa104341dc5b3d858f6ecfaff1f1">BTree</a> ()</td></tr>
<tr class="memdesc:a04ccfa104341dc5b3d858f6ecfaff1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a04ccfa104341dc5b3d858f6ecfaff1f1">More...</a><br /></td></tr>
<tr class="separator:a04ccfa104341dc5b3d858f6ecfaff1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470a5feb8d23499e401838b64080af3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a470a5feb8d23499e401838b64080af3b">~BTree</a> ()</td></tr>
<tr class="memdesc:a470a5feb8d23499e401838b64080af3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a470a5feb8d23499e401838b64080af3b">More...</a><br /></td></tr>
<tr class="separator:a470a5feb8d23499e401838b64080af3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c6ca4b4e0f18d922d6dc861583230d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a01c6ca4b4e0f18d922d6dc861583230d">create</a> (const char *filepath)</td></tr>
<tr class="memdesc:a01c6ca4b4e0f18d922d6dc861583230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> for writing.  <a href="#a01c6ca4b4e0f18d922d6dc861583230d">More...</a><br /></td></tr>
<tr class="separator:a01c6ca4b4e0f18d922d6dc861583230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cbab2be19ec6d28595a693bf57adb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a56cbab2be19ec6d28595a693bf57adb5">load</a> (const char *filepath)</td></tr>
<tr class="memdesc:a56cbab2be19ec6d28595a693bf57adb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> for reading only.  <a href="#a56cbab2be19ec6d28595a693bf57adb5">More...</a><br /></td></tr>
<tr class="separator:a56cbab2be19ec6d28595a693bf57adb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a1bd1be7b52667aacfa473b7bf0872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a75a1bd1be7b52667aacfa473b7bf0872">insert</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a75a1bd1be7b52667aacfa473b7bf0872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a value in the tree.  <a href="#a75a1bd1be7b52667aacfa473b7bf0872">More...</a><br /></td></tr>
<tr class="separator:a75a1bd1be7b52667aacfa473b7bf0872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dbd0fc0c6c563a4c2d043991e623f3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a82dbd0fc0c6c563a4c2d043991e623f3">seek</a> (const T &amp;key)</td></tr>
<tr class="memdesc:a82dbd0fc0c6c563a4c2d043991e623f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeks a value that's equivalent to the one provided.  <a href="#a82dbd0fc0c6c563a4c2d043991e623f3">More...</a><br /></td></tr>
<tr class="separator:a82dbd0fc0c6c563a4c2d043991e623f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3943fda2fde15e281b6f819b4ce7a80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#af3943fda2fde15e281b6f819b4ce7a80">getStatistics</a> (bool includeFileBlockCount=false) const </td></tr>
<tr class="memdesc:af3943fda2fde15e281b6f819b4ce7a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> usage statistics so far.  <a href="#af3943fda2fde15e281b6f819b4ce7a80">More...</a><br /></td></tr>
<tr class="separator:af3943fda2fde15e281b6f819b4ce7a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3143ea1c6a039820b8fa818cb2a335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a0a3143ea1c6a039820b8fa818cb2a335">resetStatistics</a> ()</td></tr>
<tr class="memdesc:a0a3143ea1c6a039820b8fa818cb2a335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all statistics values to 0.  <a href="#a0a3143ea1c6a039820b8fa818cb2a335">More...</a><br /></td></tr>
<tr class="separator:a0a3143ea1c6a039820b8fa818cb2a335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1458bb8edf2d2920c0b6febb17152796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a1458bb8edf2d2920c0b6febb17152796">finishInsertions</a> ()</td></tr>
<tr class="memdesc:a1458bb8edf2d2920c0b6febb17152796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the header with the total blocks in the file.  <a href="#a1458bb8edf2d2920c0b6febb17152796">More...</a><br /></td></tr>
<tr class="separator:a1458bb8edf2d2920c0b6febb17152796"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acf4235c3072d8d7127d90b19acae133d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#acf4235c3072d8d7127d90b19acae133d">readFromDisk</a> (long offset)</td></tr>
<tr class="memdesc:acf4235c3072d8d7127d90b19acae133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna um bloco com o nó lido no offset fornecido.  <a href="#acf4235c3072d8d7127d90b19acae133d">More...</a><br /></td></tr>
<tr class="separator:acf4235c3072d8d7127d90b19acae133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb1a63c1888b1bddd0e35637f149bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a9edb1a63c1888b1bddd0e35637f149bc">writeToDisk</a> (<a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a9edb1a63c1888b1bddd0e35637f149bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the node to disk.  <a href="#a9edb1a63c1888b1bddd0e35637f149bc">More...</a><br /></td></tr>
<tr class="separator:a9edb1a63c1888b1bddd0e35637f149bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa859f8b3abff5b60346c75d57e7ad1c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#aa859f8b3abff5b60346c75d57e7ad1c6">readHeader</a> () const </td></tr>
<tr class="memdesc:aa859f8b3abff5b60346c75d57e7ad1c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the file header.  <a href="#aa859f8b3abff5b60346c75d57e7ad1c6">More...</a><br /></td></tr>
<tr class="separator:aa859f8b3abff5b60346c75d57e7ad1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9728fc75ded87300e5095f2247d96f48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a9728fc75ded87300e5095f2247d96f48">writeHeader</a> (const <a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; &amp;header)</td></tr>
<tr class="memdesc:a9728fc75ded87300e5095f2247d96f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the file header in disk.  <a href="#a9728fc75ded87300e5095f2247d96f48">More...</a><br /></td></tr>
<tr class="separator:a9728fc75ded87300e5095f2247d96f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514e218903bc4c1e8992fec51039638d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a514e218903bc4c1e8992fec51039638d">insert</a> (<a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;node, T key, long rightNodeOffset=-1)</td></tr>
<tr class="memdesc:a514e218903bc4c1e8992fec51039638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for B-tree insertion.  <a href="#a514e218903bc4c1e8992fec51039638d">More...</a><br /></td></tr>
<tr class="separator:a514e218903bc4c1e8992fec51039638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:afda233e7d0574623e3e514dac40ab042"><td class="memItemLeft" align="right" valign="top">std::FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#afda233e7d0574623e3e514dac40ab042">m_file</a></td></tr>
<tr class="memdesc:afda233e7d0574623e3e514dac40ab042"><td class="mdescLeft">&#160;</td><td class="mdescRight">File pointer to the file where data will be stored.  <a href="#afda233e7d0574623e3e514dac40ab042">More...</a><br /></td></tr>
<tr class="separator:afda233e7d0574623e3e514dac40ab042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617ad6e35911cebbbc034e376263d3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a617ad6e35911cebbbc034e376263d3eb">m_root</a></td></tr>
<tr class="memdesc:a617ad6e35911cebbbc034e376263d3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Root node of the B-tree.  <a href="#a617ad6e35911cebbbc034e376263d3eb">More...</a><br /></td></tr>
<tr class="separator:a617ad6e35911cebbbc034e376263d3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dd91f75f66ad4b49489c386bb491ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_tree.html#a30dd91f75f66ad4b49489c386bb491ff">m_stats</a></td></tr>
<tr class="memdesc:a30dd91f75f66ad4b49489c386bb491ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> stores its read and write statistics.  <a href="#a30dd91f75f66ad4b49489c386bb491ff">More...</a><br /></td></tr>
<tr class="separator:a30dd91f75f66ad4b49489c386bb491ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t M&gt;<br />
class BTree&lt; T, M &gt;</h3>

<p>B-tree class. </p>
<p><a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> can be used to store T-type values in binary files for fast retrieval later. T must be a POD (Plain Old Data type) and <em>less-than</em> comparable.</p>
<p>Use the method <a class="el" href="class_b_tree.html#a01c6ca4b4e0f18d922d6dc861583230d" title="Initializes BTree for writing. ">BTree::create</a> before inserting values and, once you've finished inserting, call <a class="el" href="class_b_tree.html#a1458bb8edf2d2920c0b6febb17152796" title="Updates the header with the total blocks in the file. ">BTree::finishInsertions</a> to update the file header.</p>
<p>Use <a class="el" href="class_b_tree.html#a56cbab2be19ec6d28595a693bf57adb5" title="Initializes BTree for reading only. ">BTree::load</a> before reading values.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="class_b_tree.html">BTree&lt;int, 2&gt;</a> tree;</div><div class="line"></div><div class="line"><span class="comment">// Insert data</span></div><div class="line">tree.<a class="code" href="class_b_tree.html#a01c6ca4b4e0f18d922d6dc861583230d">create</a>(<span class="stringliteral">&quot;filename.bin&quot;</span>);</div><div class="line">tree.<a class="code" href="class_b_tree.html#a75a1bd1be7b52667aacfa473b7bf0872">insert</a>(1);</div><div class="line">tree.<a class="code" href="class_b_tree.html#a1458bb8edf2d2920c0b6febb17152796">finishInsertions</a>();</div><div class="line"></div><div class="line"><span class="comment">// Read data</span></div><div class="line">tree.<a class="code" href="class_b_tree.html#a56cbab2be19ec6d28595a693bf57adb5">load</a>(<span class="stringliteral">&quot;filename.bin&quot;</span>);</div><div class="line"><span class="keywordtype">int</span> *x = tree.<a class="code" href="class_b_tree.html#a82dbd0fc0c6c563a4c2d043991e623f3">seek</a>(1);</div><div class="line"><span class="keywordflow">if</span> (x) f(*x); <span class="comment">// Do something to x if found</span></div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the data to be stored</td></tr>
    <tr><td class="paramname">M</td><td>Tree order. Each node will store up to 2M values and have up to 2M + 1 children. A node can't be bigger than <code>BLOCK_SIZE</code> bytes. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a04ccfa104341dc5b3d858f6ecfaff1f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::<a class="el" href="class_b_tree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the statistics with 0 values and makes the file pointer point to null </p>

</div>
</div>
<a class="anchor" id="a470a5feb8d23499e401838b64080af3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::~<a class="el" href="class_b_tree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Closes the file if it's open </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a01c6ca4b4e0f18d922d6dc861583230d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> for writing. </p>
<p>Opens the file in "wb+" mode. Must be called before inserting values in the tree. Also allows reading through <a class="el" href="class_b_tree.html#a82dbd0fc0c6c563a4c2d043991e623f3" title="Seeks a value that&#39;s equivalent to the one provided. ">BTree::seek</a>.</p>
<p>If there's already a file in the filepath, it'll be overwritten.</p>
<p>The new file will be created in the provided filepath with a header and an empty root node.</p>
<p>After you've finished inserting values, call <a class="el" href="class_b_tree.html#a1458bb8edf2d2920c0b6febb17152796" title="Updates the header with the total blocks in the file. ">BTree::finishInsertions</a> to update the file header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file where the tree data will be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file was created successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a1458bb8edf2d2920c0b6febb17152796"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::finishInsertions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the header with the total blocks in the file. </p>
<p>Very important to be used once you've finished using a tree that was initialized with <a class="el" href="class_b_tree.html#a01c6ca4b4e0f18d922d6dc861583230d" title="Initializes BTree for writing. ">BTree::create</a>. </p>

</div>
</div>
<a class="anchor" id="af3943fda2fde15e281b6f819b4ce7a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::<a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a> &amp; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::getStatistics </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeFileBlockCount</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> usage statistics so far. </p>
<p>Including the quantity of blocks in the file is optional because it requires reading the file header to update the field. The read value will be stored in memory and can be accessed later without reading the file header again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includeFileBlockCount</td><td>True if you want to update the <a class="el" href="struct_b_tree_1_1_statistics.html#ad2a5bfa125c168b1c9a0698f74c610ea" title="Quantity of blocks stored in disk. ">Statistics::blocksInDisk</a> value, false otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_b_tree_1_1_statistics.html" title="Stored analytics of the BTree usage. ">Statistics</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a75a1bd1be7b52667aacfa473b7bf0872"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a value in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a514e218903bc4c1e8992fec51039638d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::<a class="el" href="struct_b_tree_1_1_overflow_result.html">OverflowResult</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>rightNodeOffset</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method for B-tree insertion. </p>
<p>If the node is a leaf, it seeks the node pointer for the node in which the value must be inserted and tries to insert again recursively. If the node isn't a leaf, inserts normally.</p>
<p>In case of overflow, the method will split the node provided as parameter and return an <a class="el" href="struct_b_tree_1_1_overflow_result.html" title="Auxiliary struct with results from an insertion overflow. ">OverflowResult</a> instance with data for the parent node to deal with the overflow. The parent will try to insert again but, this time, in itself.</p>
<p>The value of rightNodeOffset should be different from -1 only if the method is dealing with an overflow. In this case, it's the parent node which must be trying to insert the node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node in which to insert </td></tr>
    <tr><td class="paramname">key</td><td>Value to insert </td></tr>
    <tr><td class="paramname">rightNodeOffset</td><td>Offset of the node to the right of the value to insert; if -1, the node to the right doesn't exist yet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer with an <a class="el" href="struct_b_tree_1_1_overflow_result.html" title="Auxiliary struct with results from an insertion overflow. ">OverflowResult</a> instance in case of overflow, null otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a56cbab2be19ec6d28595a693bf57adb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> for reading only. </p>
<p>Opens the file in "rb" mode. Must be before reading values form a file where values have already been inserted. Insertions won't be possible.</p>
<p>The file must have been previously created by a <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> which successfully called <a class="el" href="class_b_tree.html#a01c6ca4b4e0f18d922d6dc861583230d" title="Initializes BTree for writing. ">BTree::create</a> and <a class="el" href="class_b_tree.html#a1458bb8edf2d2920c0b6febb17152796" title="Updates the header with the total blocks in the file. ">BTree::finishInsertions</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>Path to the file where tree data can be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if it was possible to open the file in filepath </dd></dl>

</div>
</div>
<a class="anchor" id="acf4235c3072d8d7127d90b19acae133d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::<a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::readFromDisk </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retorna um bloco com o nó lido no offset fornecido. </p>
<p>Assumes that the provided offset will always be valid. If an invalid offset is provided, the result is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Node's offset in the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="union_block.html" title="Union for reading and writing blocks containing serialized data. ">Block</a> with the node found in the provided offset </dd></dl>

</div>
</div>
<a class="anchor" id="aa859f8b3abff5b60346c75d57e7ad1c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt; typename <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::<a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::readHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the file header. </p>
<p>This method assumes that <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> has already been initialized and the file is open. Otherwise, behavior is undefined.</p>
<p>Increments <a class="el" href="struct_b_tree_1_1_statistics.html#a281fc816fdabbee94024bd7a0acef9fa" title="Quantity of blocks read since the tree was initialized. ">Statistics::blocksRead</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="union_block.html" title="Union for reading and writing blocks containing serialized data. ">Block</a> with the file header </dd></dl>

</div>
</div>
<a class="anchor" id="a0a3143ea1c6a039820b8fa818cb2a335"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::resetStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset all statistics values to 0. </p>
<p>Use with caution </p>

</div>
</div>
<a class="anchor" id="a82dbd0fc0c6c563a4c2d043991e623f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; T &gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::seek </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seeks a value that's equivalent to the one provided. </p>
<p>If the value is not found, a null pointer will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The value to seek</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer with the value if found, null otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9728fc75ded87300e5095f2247d96f48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::writeHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_file_header.html">FileHeader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the file header in disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td><a class="el" href="union_block.html" title="Union for reading and writing blocks containing serialized data. ">Block</a> with file header to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9edb1a63c1888b1bddd0e35637f149bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::writeToDisk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_block.html">Block</a>&lt; <a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the node to disk. </p>
<p>If the node still hasn't been written to disk (<a class="el" href="struct_b_tree_1_1_b_node.html#a6e78060e2a5b8ffb16e9166ae1338d88" title="Disk address. ">BNode::offset</a> == -1), it'll be appended to the end of the file and <a class="el" href="struct_b_tree_1_1_b_node.html#a6e78060e2a5b8ffb16e9166ae1338d88" title="Disk address. ">BNode::offset</a> will be updated. In case this happens, <a class="el" href="struct_b_tree_1_1_statistics.html#a06374a2c0dfc1019b1219e17203734bc" title="Quantity of blocks created since the tree was initialized. ">Statistics::blocksCreated</a> will be incremented.</p>
<p>If the node has already been written to disk it'll simply be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Node to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afda233e7d0574623e3e514dac40ab042"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::FILE* <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::m_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File pointer to the file where data will be stored. </p>

</div>
</div>
<a class="anchor" id="a617ad6e35911cebbbc034e376263d3eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="union_block.html">Block</a>&lt;<a class="el" href="struct_b_tree_1_1_b_node.html">BNode</a>&gt; <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::m_root</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Root node of the B-tree. </p>

</div>
</div>
<a class="anchor" id="a30dd91f75f66ad4b49489c386bb491ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_b_tree_1_1_statistics.html">Statistics</a> <a class="el" href="class_b_tree.html">BTree</a>&lt; T, M &gt;::m_stats</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Where <a class="el" href="class_b_tree.html" title="B-tree class. ">BTree</a> stores its read and write statistics. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_b_tree_8hpp_source.html">BTree.hpp</a></li>
<li>include/<a class="el" href="_b_tree_8inl.html">BTree.inl</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
